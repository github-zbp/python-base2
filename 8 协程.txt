我们将以socket编程模拟http请求和多路复用io模型逐步引入协程

首先，使用socket通信模拟http请求，下面是客户端的请求代码：

# coding=utf-8

import socket

# 使用socket请求我自己的博客的首页
host = "zbpblog.com"
port = 80

# 创建socket
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 建立tcp连接，三次握手
client.connect((host, port))

# 发送请求报文, 请求报文可以不用自己写，直接在chrome浏览器F12即可查看
# 报文内容只需要请求头（GET /xxx HTTP/1.1）和请求行中的Host和Connection字段即可，具体要看你请求的页面要求必须有哪些请求行字段。报文最后必须使用两个\r\n表示请求报文结束，否则运行到下面recv的时候会一直阻塞，因为服务端会认为你的报文没发完（所以服务端就不执行send，所以客户端recv就阻塞住了）

request_msg = "GET / HTTP/1.1\r\nHost: zbpblog.com\r\nConnection: close\r\n\r\n"    # Connection为close，表示使用短连接的方式
# request_msg = "GET / HTTP/1.1\r\nHost: zbpblog.com\r\nConnection: keep-alive\r\n\r\n"    # Connection为keep-alive，表示使用长连接的方式

client.send(request_msg.encode("utf-8"))     # 发送数据, 发送的数据得是字节流而不能是字符串，所以要对字符串编码一下转为byte类型

# 等待服务器返回响应,返回的数据可能大于1024字节，所以要调用多次recv直到接收完全部的数据
data = b""      # 接收到的字节流数据
while True:
    res = client.recv(1024)     # 该recv会阻塞直到服务端有响应返回
	print(res)					
    if res:
        data += res
    else:
        break

print(data.decode("utf-8"))
client.close()

以短连接的方式请求的话，程序运行的结果是：当服务端将响应发送完之后，会再发送一个空消息以表示响应发送完毕（此时服务端会主动关闭连接，也就是在服务端执行client.close()），以此方式告诉客户端可以关闭连接了(此时在客户端执行client.close())。
以长连接的方式请求的话，程序运行的结果是：服务端接收到请求报文后会立刻返回响应（可以通过while循环中的print查看到），但是发送完响应之后不会立刻发送空消息。所以客户端在接收完响应报文之后就又被client.recv()给阻塞住了。此时服务端在等客户端还会不会发送新的请求，直到等待了超时时间的时长，服务端才发送空消息（服务端关闭连接），此时客户端才真正跳出循环关闭连接(客户端执行client.close())。




我们可以做个实验，把接收服务器响应的代码封装起来，我们使用短连接发送两次请求：

def getResponse():
    data = b""      # 接收到的字节流数据
    
    # 等待服务器返回响应,返回的数据可能大于1024字节，所以要调用多次recv直到接收完全部的数据
    while True:
        res = client.recv(1024)     # 该recv会阻塞直到服务端有响应返回

        if res:
            data += res
        else:
            break

    return data.decode("utf-8")

client.send(request_msg.encode("utf-8"))     # 发送第一次请求
print(getResponse())						 # 获取响应，由于是短连接，所以服务端返回响应后就主动关闭了客户端的套接字，所以下面的请求服务端就接收不到了

print("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")

client.send(request_msg.encode("utf-8"))
print(getResponse())						 # 第二次getResponse不会阻塞，马上会得到返回，因为服务端压根就没接收到请求

===========

如果是这样调用也一样只能得到一次响应

client.send(request_msg.encode("utf-8"))     # 发送第一次请求
client.send(request_msg.encode("utf-8"))	 # 发送第二次请求
print(getResponse())						 # getResponse内部能马上接收到2次请求的数据（recv会立刻返回数据），但是数据发送完后会受到recv的阻塞，等个几十秒后，服务端关闭连接，阻塞解除，getResponse函数才返回结果

print(getResponse())						 # 没响应，因为服务端已关闭与客户端连接

这样的话，两次请求的数据就合在一起分不开了。

===========


